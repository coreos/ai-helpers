import argparse
import logging
import os
import re
import subprocess
from datetime import datetime
from typing import Dict

import requests

logger = logging.getLogger(__name__)


def extract_all_ocp_versions():
    """
    Extract all OCP version names from the /graph endpoint.
    Returns:
        list: A list of version names
    """
    try:
        url = (
            "https://amd64.ocp.releases.ci.openshift.org/api/v1/releasestreams/accepted"
        )
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        versions = []
        if isinstance(data, dict):
            for base_version, version_list in data.items():
                if isinstance(version_list, list):
                    for version in version_list:
                        # Filter out release candidates
                        if not re.search(r"-rc\.\d+", version):
                            versions.append(version)

        def version_key(version):
            """
            Sorts a list by prioritizing date patterns first.
            - Returns (1, datetime_object) for date patterns.
            - Returns (0, version_tuple) for all other patterns.
            """
            # Check for the date pattern first (Priority 1)
            date_match = re.search(r"(\d{4}-\d{2}-\d{2}-\d{6})", version)
            if date_match:
                date_str = date_match.group(1)
                try:
                    date_obj = datetime.strptime(date_str, "%Y-%m-%d-%H%M%S")
                    # This is the highest priority group
                    return (1, date_obj)
                except ValueError:
                    pass  # Fall through if date is malformed

            # If no date is found, use your original logic (Priority 0)
            try:
                if "-ec." in version:
                    base, ec = version.split("-ec.")
                    major, minor, patch = map(int, base.split("."))
                    # Nest your original tuple inside the low priority group
                    return (0, (major, minor, patch, int(ec)))
                else:
                    parts = tuple(map(int, version.split(".")))
                    return (0, parts)
            except (ValueError, IndexError):
                # Fallback for unparseable strings like "nightly"
                return (0, (0, 0, 0, 0))

        def is_valid_ocp_version(version):
            """Check if version is OCP 4.12 or higher."""
            try:
                if not version.startswith("4."):
                    return False
                parts = version.split(".")
                if len(parts) < 2:
                    return False
                minor = int(parts[1])
                return minor >= 12
            except (ValueError, IndexError):
                return False

        filtered_versions = [v for v in versions if is_valid_ocp_version(v)]
        sorted_versions = sorted(filtered_versions, key=version_key, reverse=True)
        return sorted_versions
    except requests.exceptions.RequestException as e:
        logger.error(f"An error occurred fetching JSON data: {e}")
        return None
    except ValueError as e:
        logger.error(f"An error occurred parsing JSON data: {e}")
        return None


def get_latest_ocp_version() -> Dict[str, str]:
    """Get the latest OCP version for all OCP versions.
    Returns:
        dict: Mapping of major.minor versions to their latest z-stream versions.
    """
    all_versions = extract_all_ocp_versions() or []

    latest_versions = {}
    for version in all_versions:
        major_minor = ".".join(version.split(".")[:2])  # Get X.Y from X.Y.Z
        if major_minor not in latest_versions:
            latest_versions[major_minor] = version

    return latest_versions


def verify_rhcos_builds(ocp_version: str, package_name: str) -> dict:
    """
    Verify RHCOS builds by checking for packages in the build.

    Returns:
        dict: Dictionary containing all matching package lines and the command used.
    """
    logger.info(f"Verifying RHCOS builds for package: {package_name}")

    registry_auth_file = os.getenv("REGISTRY_AUTH_FILE")
    latest_ocp_versions = get_latest_ocp_version()
    if ocp_version not in latest_ocp_versions:
        logger.error(f"OCP version {ocp_version} not found in latest OCP versions")
        return None
    ocp_version = latest_ocp_versions[ocp_version]

    # Determine RHEL CoreOS image name
    if "4.12" in ocp_version:
        rhel_coreos = "rhel-coreos-8"
    else:
        rhel_coreos = "rhel-coreos"

    try:
        # The pattern to search for: a hyphen, then YYYY-MM-DD-HHMMSS
        date_time_pattern = r"-\d{4}-\d{2}-\d{2}-\d{6}"

        if "konflux-nightly" in ocp_version:
            image = f"registry.ci.openshift.org/ocp/konflux-release:{ocp_version}"
        elif ("ci" in ocp_version or "nightly" in ocp_version) and re.search(
            date_time_pattern, ocp_version
        ):
            image = f"registry.ci.openshift.org/ocp/release:{ocp_version}"
        else:
            image = f"quay.io/openshift-release-dev/ocp-release:{ocp_version}-x86_64"

        # Step 1: Get the container image
        image_cmd = [
            "oc",
            "adm",
            "release",
            "info",
            f"{image}",
            "--image-for",
            rhel_coreos,
        ]

        if registry_auth_file:
            image_cmd.append("--registry-config")
            image_cmd.append(f"{registry_auth_file}")

        image_result = subprocess.run(
            image_cmd, check=True, text=True, capture_output=True
        )
        container_image = image_result.stdout.strip()

        # Step 2: Run podman with the package query
        podman_cmd = ["podman", "run"]
        if registry_auth_file:
            podman_cmd.extend(["--authfile", f"{registry_auth_file}"])
        podman_cmd.extend(["--quiet", "--rm", container_image, "rpm", "-qa"])

        rpm_result = subprocess.run(
            podman_cmd, check=True, text=True, capture_output=True
        )

        # Step 3: Filter for the package (in Python, not shell)
        package_lines = [
            line for line in rpm_result.stdout.split("\n") if package_name in line
        ]

        # Construct command string for logging (not execution)
        command_str = (
            f"podman run --quiet --rm {container_image} rpm -qa | grep {package_name}"
        )

        logger.info(f"Found {len(package_lines)} matching packages for {package_name}")

        return {"packages_found": package_lines, "command_used": command_str}

    except subprocess.CalledProcessError as e:
        logger.error(f"Command execution failed: {e}")
        return {
            "package_lines": [],
            "command_used": "N/A",
            "error": str(e),
        }
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return {
            "package_lines": [],
            "command_used": "N/A",
            "error": str(e),
        }


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Verify RHCOS builds by checking for packages in the build"
    )
    parser.add_argument(
        "--ocp-version",
        type=str,
        required=True,
        help="OpenShift version (e.g., '4.12', '4.13.0-0.nightly-2024-01-01-000000')",
    )
    parser.add_argument(
        "--package",
        type=str,
        required=True,
        help="Package name to search for (e.g., 'kernel', 'openssl')",
    )
    args = parser.parse_args()
    result = verify_rhcos_builds(args.ocp_version, args.package)
    print(result)
